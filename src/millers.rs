use num_bigint_dig::{BigUint, ToBigUint};

//Make function public
pub fn is_prime_miller(n: &BigUint) -> bool {
    if *n == 1.to_biguint().unwrap() {
        return false;
    } else if *n == 2.to_biguint().unwrap() {
        return true;
    } else if *n == 3.to_biguint().unwrap() {
        return true
    }
    for _i in 0..10 {
        let ret = miller_test(&n);
        if ret == false {
            return false
        }
    }
    return true
}


fn miller_test(n: &BigUint) -> bool {
    let two_as_bigint: BigUint = BigUint::from(2u8);
    let zero_as_bigint: BigUint = BigUint::from(0u8);
    let one_as_bigint: BigUint = BigUint::from(1u8);

    let mut t = n - &one_as_bigint;
    let mut s: u64 = 0;

    while &t % &two_as_bigint == zero_as_bigint {
        t = &t / &two_as_bigint;
        s += 1;
    }
    // Generate a bigint random number...
    let b1: u128 = rand::random();
    let b2: u128 = rand::random();
    let mut b = (b1.to_biguint().unwrap() * b2.to_biguint().unwrap()) % n;

    if b == zero_as_bigint {
        b += &one_as_bigint;
    }

    //Pow bigint
    let ret = b.modpow(&t, &n);

    if ret == one_as_bigint {
        return true
    }

    for _i in 0..s {
        if b.modpow(&t, &n) == n-&one_as_bigint {
            return true
        }
        t *= &two_as_bigint;
    }
    return false
}

#[test]
fn millers_1_to_1million() {
    use primes::is_prime;
    for i in 0..(1 << 12) {
        let result1 = is_prime_miller(&i.to_biguint().unwrap());
        let result2 = is_prime(i);
        assert_eq!(result1, result2);
    }
}

#[test]
fn millers_bigint_200_prime() {

    use std::str::FromStr;
    let large_number_1 = "643808006803554439230129854961492699151386107534013432918073439524138264842370630061369715394739134090922937332590384720397133335969549256322620979036686633213903952966175107096769180017646161851573147596390153";
    let large_number_2 = "449417999055441493994709297093108513015373787049558499205492347871729927573118262811508386655998299074566974373711472560655026288668094291699357843464363003144674940345912431129144354948751003607115263071543163";
    let large_number_3 = "230975859993204150666423538988557839555560243929065415434980904258310530753006723857139742334640122533598517597674807096648905501653461687601339782814316124971547968912893214002992086353183070342498989426570593";
    let large_number_4 = "879976242195951958890801816612768566943805170226410617823301865416003514546684111640331356490455690766475339038983303063831818394885482954417406863802340357540397021808027209610884076158915519334125353771492979";
    let large_number_5 = "110975366417606590833967199024636437460214709654546954443361638176229883140910302915147996598210506836614251268964446338737195911448213015377273363573074752120243818732263682864461580384738021460717565715722503";
    let large_number_6 = "614865347947412054998871912138166461049314312490725112873271296842414474254904548663296952332559110113044820194651149624596490803942453669130989178203975581114455363503708800628353373554758750709244049339485669";


    assert!(is_prime_miller(
        &BigUint::from_str(large_number_1).unwrap()
    ));

    assert!(is_prime_miller(
        &BigUint::from_str(large_number_2).unwrap()
    ));

    assert!(is_prime_miller(
        &BigUint::from_str(large_number_4).unwrap()
    ));

    assert!(is_prime_miller(
        &BigUint::from_str(large_number_5).unwrap()
    ));

    assert!(is_prime_miller(
        &BigUint::from_str(large_number_6).unwrap()
    ));

    assert!(is_prime_miller(
        &BigUint::from_str(large_number_3).unwrap()
    ));
}

#[test]
fn millers_bigint_300_prime() {

    use std::str::FromStr;

    let large_number_1 = "203956878356401977405765866929034577280193993314348263094772646453283062722701277632936616063144088173312372882677123879538709400158306567338328279154499698366071906766440037074217117805690872792848149112022286332144876183376326512083574821647933992961249917319836219304274280243803104015000563790123";
    let large_number_2 = "531872289054204184185084734375133399408303613982130856645299464930952178606045848877129147820387996428175564228204785846141207532462936339834139412401975338705794646595487324365194792822189473092273993580587964571659678084484152603881094176995594813302284232006001752128168901293560051833646881436219";
    let large_number_3 = "319705304701141539155720137200974664666792526059405792539680974929469783512821793995613718943171723765238853752439032835985158829038528214925658918372196742089464683960239919950882355844766055365179937610326127675178857306260955550407044463370239890187189750909036833976197804646589380690779463976173";

    assert!(is_prime_miller(
        &BigUint::from_str(large_number_1).unwrap()
    ));

    assert!(is_prime_miller(
        &BigUint::from_str(large_number_2).unwrap()
    ));

    assert!(is_prime_miller(
        &BigUint::from_str(large_number_3).unwrap()
    ));
}

#[test]
fn millers_bigint_not_prime() {

    use std::str::FromStr;

    let large_number_1 = "643808006803554439230129854961492699151386107534013432918073439524138264842370630061369715394739134090922937332590384720397133335969549256322620979036686633213903952966175107096769180017646161851573147596390582";
    let large_number_2 = "449417999055441493994709297093108513015373787049558499205492347871729927573118262811508386655998299074566974373711472560655026288668094291699357843464363003144674940345912431129144354948751003607115263071543439";
    let large_number_3 = "230975859993204150666423538988557839555560243929065415434980904258310530753006723857139742334640122533598517597674807096648905501653461687601339782814316124971547968912893214002992086353183070385917091570192798";

    assert!(!is_prime_miller(
        &BigUint::from_str(large_number_1).unwrap()
    ));

    assert!(!is_prime_miller(
        &BigUint::from_str(large_number_2).unwrap()
    ));

    assert!(!is_prime_miller(
        &BigUint::from_str(large_number_3).unwrap()
    ))
}